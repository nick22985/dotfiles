#!/usr/bin/env bash

# Update all submodules to latest commit on their respective branches
set -e

# Set DOTFILES_DIR if not already set
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
export DOTFILES_DIR="${DOTFILES_DIR:-$script_dir}"

# Source shared utilities
source "$DOTFILES_DIR/lib/utils.sh"

# Parse arguments
parse_args "$@"

log "Updating all submodules to latest commits..."

cd "$DOTFILES_DIR"

# Check if we have any submodules
if [[ ! -f .gitmodules ]]; then
    log "⚠ No .gitmodules file found"
    exit 0
fi

# Get list of ALL submodules
all_submodules=$(git config --file .gitmodules --get-regexp path | awk '{ print $2 }')

# Get list of nick22985 submodules
nick_submodules=$(git config --file .gitmodules --get-regexp url | grep "nick22985" | awk '{print $1}' | sed 's/submodule\.\(.*\)\.url/\1/' | while read -r name; do git config --file .gitmodules --get "submodule.$name.path"; done)

if [[ -z "$all_submodules" ]]; then
    log "⚠ No submodules found"
    exit 0
fi

log "Found submodules:"
echo "$all_submodules" | while read -r submodule; do
    # Check if this is a nick22985 submodule
    if echo "$nick_submodules" | grep -q "^$submodule$"; then
        log "  → $submodule (nick22985 - will commit/push)"
    else
        log "  → $submodule (external - update only)"
    fi
done

# Update each submodule
updated_count=0
total_count=0

echo "$all_submodules" | while read -r submodule_path; do
    total_count=$((total_count + 1))

    if [[ ! -d "$submodule_path" ]]; then
        log "⚠ Submodule directory not found: $submodule_path"
        continue
    fi

    # Check if this is a nick22985 submodule
    is_nick_submodule=false
    if echo "$nick_submodules" | grep -q "^$submodule_path$"; then
        is_nick_submodule=true
        log "→ Updating nick22985 submodule: $submodule_path"
    else
        log "→ Updating external submodule: $submodule_path"
    fi

    if [[ $DRY_RUN == "0" ]]; then
        # Get the configured branch for this submodule (if any)
        submodule_name=$(git config --file .gitmodules --get-regexp "submodule\..*\.path" | grep "$submodule_path" | sed 's/submodule\.\(.*\)\.path.*/\1/')
        branch=$(git config --file .gitmodules --get "submodule.$submodule_name.branch" 2>/dev/null || echo "")

        # Change to submodule directory
        (
            cd "$submodule_path"

            # Get current commit before update
            old_commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")

            # Only commit/push changes for nick22985 submodules
            if [[ "$is_nick_submodule" == "true" ]]; then
                # Check if there are any uncommitted changes (modified, staged, or untracked files)
                if ! git diff --quiet || ! git diff --cached --quiet || [[ -n $(git ls-files --others --exclude-standard) ]]; then
                    log "  → Found uncommitted changes, committing..."
                    
                    # Add all changes
                    git add . 2>/dev/null || true
                    
                    # Commit with a generic message if there are staged changes
                    if ! git diff --cached --quiet; then
                        git commit -m "Auto-commit changes from dotfiles update" || {
                            log "  ⚠ Failed to commit changes"
                            exit 1
                        }
                        log "  ✓ Committed local changes"
                    fi
                fi
            fi

            # Fetch latest changes
            git fetch origin 2>/dev/null || {
                log "⚠ Failed to fetch from origin for $submodule_path"
                exit 1
            }

            # Determine which branch/ref to update to
            if [[ -n "$branch" ]]; then
                # Use specified branch
                target_branch="$branch"
                target_ref="origin/$branch"
                log "  → Using configured branch: $branch"
            else
                # Use default branch (usually main/master)
                default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
                target_branch="$default_branch"
                target_ref="origin/$default_branch"
                log "  → Using default branch: $default_branch"
            fi

            if [[ "$is_nick_submodule" == "true" ]]; then
                # For nick22985 submodules: ensure we're on the correct local branch and pull/push
                current_branch=$(git branch --show-current 2>/dev/null || echo "")
                if [[ "$current_branch" != "$target_branch" ]]; then
                    # Switch to or create the target branch
                    if git show-ref --verify --quiet "refs/heads/$target_branch"; then
                        git checkout "$target_branch" 2>/dev/null || {
                            log "  ⚠ Failed to checkout branch $target_branch"
                            exit 1
                        }
                    else
                        git checkout -b "$target_branch" "$target_ref" 2>/dev/null || {
                            log "  ⚠ Failed to create and checkout branch $target_branch"
                            exit 1
                        }
                    fi
                    log "  → Switched to branch: $target_branch"
                fi

                # Pull latest changes
                if git pull origin "$target_branch" 2>/dev/null; then
                    new_commit=$(git rev-parse HEAD)

                    if [[ "$old_commit" != "$new_commit" ]]; then
                        log "  ✓ Updated from $old_commit to $new_commit"
                        updated_count=$((updated_count + 1))
                    else
                        log "  ✓ Already up to date ($new_commit)"
                    fi
                else
                    log "  ⚠ Failed to pull from $target_ref"
                    exit 1
                fi

                # Push any local commits that haven't been pushed
                if git log "@{u}.." --oneline 2>/dev/null | grep -q .; then
                    log "  → Pushing local commits..."
                    if git push origin "$target_branch" 2>/dev/null; then
                        log "  ✓ Pushed local commits to origin"
                    else
                        log "  ⚠ Failed to push to origin"
                    fi
                fi
            else
                # For external submodules: just update to latest commit
                if git checkout -q "$target_ref" 2>/dev/null; then
                    new_commit=$(git rev-parse HEAD)

                    if [[ "$old_commit" != "$new_commit" ]]; then
                        log "  ✓ Updated from $old_commit to $new_commit"
                        updated_count=$((updated_count + 1))
                    else
                        log "  ✓ Already up to date ($new_commit)"
                    fi
                else
                    log "  ⚠ Failed to checkout $target_ref"
                    exit 1
                fi
            fi
        ) || {
            log "⚠ Failed to update submodule: $submodule_path"
            continue
        }
    else
        log "  Would update submodule: $submodule_path"
    fi
done

# Update the main repository's submodule references
if [[ $DRY_RUN == "0" ]]; then
    log "→ Updating submodule references in main repository..."

    # Add all submodule changes
    git add . 2>/dev/null || true

    # Check if there are any changes to commit
    if git diff --cached --quiet; then
        log "✓ No submodule reference updates needed"
    else
        log "→ Committing submodule reference updates..."
        git commit -m "Update submodules to latest commits" || {
            log "⚠ Failed to commit submodule updates"
        }
        log "✓ Submodule references updated and committed"
    fi
else
    log "Would update submodule references in main repository"
fi

if [[ $DRY_RUN == "0" ]]; then
    log "✓ Submodule update complete"
else
    log "Would update all submodules to latest commits"
fi
