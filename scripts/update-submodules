#!/usr/bin/env bash

# Update all submodules to latest commit on their respective branches
set -e

# Set DOTFILES_DIR if not already set
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
export DOTFILES_DIR="${DOTFILES_DIR:-$script_dir}"

# Source shared utilities
source "$DOTFILES_DIR/lib/utils.sh"

# Parse arguments
parse_args "$@"

log "Updating nick22985 submodules to latest commits..."

cd "$DOTFILES_DIR"

# Check if we have any submodules
if [[ ! -f .gitmodules ]]; then
    log "⚠ No .gitmodules file found"
    exit 0
fi

# Get list of nick22985 submodules only
submodules=$(git config --file .gitmodules --get-regexp url | grep "nick22985" | awk '{print $1}' | sed 's/submodule\.\(.*\)\.url/\1/' | while read -r name; do git config --file .gitmodules --get "submodule.$name.path"; done)

if [[ -z "$submodules" ]]; then
    log "⚠ No nick22985 submodules found"
    exit 0
fi

log "Found nick22985 submodules:"
echo "$submodules" | while read -r submodule; do
    log "  → $submodule"
done

# Update each submodule
updated_count=0
total_count=0

echo "$submodules" | while read -r submodule_path; do
    total_count=$((total_count + 1))

    if [[ ! -d "$submodule_path" ]]; then
        log "⚠ Submodule directory not found: $submodule_path"
        continue
    fi

    log "→ Updating submodule: $submodule_path"

    if [[ $DRY_RUN == "0" ]]; then
        # Get the configured branch for this submodule (if any)
        submodule_name=$(git config --file .gitmodules --get-regexp "submodule\..*\.path" | grep "$submodule_path" | sed 's/submodule\.\(.*\)\.path.*/\1/')
        branch=$(git config --file .gitmodules --get "submodule.$submodule_name.branch" 2>/dev/null || echo "")

        # Change to submodule directory
        (
            cd "$submodule_path"

            # Get current commit before update
            old_commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")

            # Check if there are any uncommitted changes
            if ! git diff --quiet || ! git diff --cached --quiet; then
                log "  → Found uncommitted changes, committing..."
                
                # Add all changes
                git add . 2>/dev/null || true
                
                # Commit with a generic message if there are staged changes
                if ! git diff --cached --quiet; then
                    git commit -m "Auto-commit changes from dotfiles update" || {
                        log "  ⚠ Failed to commit changes"
                        exit 1
                    }
                    log "  ✓ Committed local changes"
                fi
            fi

            # Fetch latest changes
            git fetch origin 2>/dev/null || {
                log "⚠ Failed to fetch from origin for $submodule_path"
                exit 1
            }

            # Determine which branch/ref to update to
            if [[ -n "$branch" ]]; then
                # Use specified branch
                target_branch="$branch"
                target_ref="origin/$branch"
                log "  → Using configured branch: $branch"
            else
                # Use default branch (usually main/master)
                default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
                target_branch="$default_branch"
                target_ref="origin/$default_branch"
                log "  → Using default branch: $default_branch"
            fi

            # Ensure we're on the correct local branch
            current_branch=$(git branch --show-current 2>/dev/null || echo "")
            if [[ "$current_branch" != "$target_branch" ]]; then
                # Switch to or create the target branch
                if git show-ref --verify --quiet "refs/heads/$target_branch"; then
                    git checkout "$target_branch" 2>/dev/null || {
                        log "  ⚠ Failed to checkout branch $target_branch"
                        exit 1
                    }
                else
                    git checkout -b "$target_branch" "$target_ref" 2>/dev/null || {
                        log "  ⚠ Failed to create and checkout branch $target_branch"
                        exit 1
                    }
                fi
                log "  → Switched to branch: $target_branch"
            fi

            # Pull latest changes
            if git pull origin "$target_branch" 2>/dev/null; then
                new_commit=$(git rev-parse HEAD)

                if [[ "$old_commit" != "$new_commit" ]]; then
                    log "  ✓ Updated from $old_commit to $new_commit"
                    updated_count=$((updated_count + 1))
                else
                    log "  ✓ Already up to date ($new_commit)"
                fi
            else
                log "  ⚠ Failed to pull from $target_ref"
                exit 1
            fi

            # Push any local commits that haven't been pushed
            if git log "@{u}.." --oneline 2>/dev/null | grep -q .; then
                log "  → Pushing local commits..."
                if git push origin "$target_branch" 2>/dev/null; then
                    log "  ✓ Pushed local commits to origin"
                else
                    log "  ⚠ Failed to push to origin"
                fi
            fi
        ) || {
            log "⚠ Failed to update submodule: $submodule_path"
            continue
        }
    else
        log "  Would update submodule: $submodule_path"
    fi
done

# Update the main repository's submodule references
if [[ $DRY_RUN == "0" ]]; then
    log "→ Updating submodule references in main repository..."

    # Add all submodule changes
    git add . 2>/dev/null || true

    # Check if there are any changes to commit
    if git diff --cached --quiet; then
        log "✓ No submodule reference updates needed"
    else
        log "→ Committing submodule reference updates..."
        git commit -m "Update nick22985 submodules to latest commits" || {
            log "⚠ Failed to commit submodule updates"
        }
        log "✓ Submodule references updated and committed"
    fi
else
    log "Would update submodule references in main repository"
fi

if [[ $DRY_RUN == "0" ]]; then
    log "✓ Submodule update complete"
else
    log "Would update all nick22985 submodules to latest commits"
fi
